import {Command} from '@oclif/command'

import {Utils} from './utils'
import {Writer} from './writer'

export namespace CSharpGenerator {
  export function header(
    description: string,
    space: string,
    className: string,
    writer: Writer
  ): void {
    writer.writeLine(
      `// <auto-generated>
// Code generated by ${description}
// Tool github: https://github.com/microsoft/botbuilder-tools
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
using Newtonsoft.Json;
using System.Collections.Generic;
using Microsoft.Bot.Builder;
using Microsoft.Bot.Builder.AI.Luis;
namespace ${space}
{`
    )
    writer.increaseIndentation()

    //Main class
    writer.writeLineIndented(
      `public partial class ${className}: IRecognizerConvert`
    )
    writer.writeLineIndented('{')
    writer.increaseIndentation()

    //Text
    writer.writeLineIndented('[JsonProperty("text")]')
    writer.writeLineIndented('public string Text;')
    writer.writeLine()
    writer.writeLineIndented('[JsonProperty("alteredText")]')
    writer.writeLineIndented('public string AlteredText;')
  }

  export function intents(intents: any, writer: Writer): void {
    writer.writeLineIndented('public enum Intent {')
    writer.increaseIndentation()
    let firstIntent = true
    intents.forEach((intent: any) => {
      if (firstIntent) {
        firstIntent = false
      } else {
        writer.writeLine(', ')
      }
      writer.writeIndented(Utils.normalizeName(intent.name))
    })
    writer.writeLine()
    writer.decreaseIndentation()

    writer.writeLineIndented('};') // Intent enum
    writer.writeLineIndented('[JsonProperty("intents")]')
    writer.writeLineIndented('public Dictionary<Intent, IntentScore> Intents;')
  }

  export function propertyName(name: any): string {
    return Utils.jsonPropertyName(name)
  }

  export function writeEntity(
    entity: any,
    type: any,
    writer: Writer
  ): void {
    Utils.entityApply(entity, ((name: string) => {
      const realName = propertyName(name)
      switch (type as string) {
      case 'age':
        writer.writeLineIndented(`public Age[] ${realName};`)
        break
      case 'datetimeV2':
        writer.writeLineIndented(`public DateTimeSpec[] ${realName};`)
        break
      case 'dimension':
        writer.writeLineIndented(`public Dimension[] ${realName};`)
        break
      case 'geographyV2':
        writer.writeLineIndented(`public GeographyV2[] ${realName};`)
        break
      case 'list':
        writer.writeLineIndented(`public string[][] ${realName};`)
        break
      case 'money':
        writer.writeLineIndented(`public Money[] ${realName};`)
        break
      case 'ordinalV2':
        writer.writeLineIndented(`public OrdinalV2[] ${realName};`)
        break
      case 'temperature':
        writer.writeLineIndented(`public Temperature[] ${realName};`)
        break
      case 'number':
      case 'ordinal':
      case 'percentage':
        writer.writeLineIndented(`public double[] ${realName};`)
        break
      default:
        writer.writeLineIndented(`public string[] ${realName};`)
      }
    }))
  }

  export function writeEntities(
    entities: Array<any>,
    app: any,
    description: string,
    writer: Writer
  ): void {
    if (entities.length > 0) {
      writer.writeLine()
      writer.writeLineIndented(`// ${description}`)
      let first = true
      entities.forEach(entity => {
        if (first) {
          first = false
        } else {
          writer.writeLine()
        }
        writeEntity(
          entity,
          Utils.isList(entity.name, app) ? 'list' : entity.name,
          writer
        )
      })
    }
  }

  export function entities(app: any, writer: Writer): void {
    // Entities
    writer.writeLine()
    writer.writeLineIndented('public class _Entities')
    writer.writeLineIndented('{')
    writer.increaseIndentation()
    if (
      app.entities !== null &&
      app.entities !== undefined &&
      app.entities.length > 0
    ) {
      writer.writeLineIndented('// Simple entities')
      let first = true
      app.entities.forEach((entity: any) => {
        if (first) {
          first = false
        } else {
          writer.writeLine()
        }
        writeEntity(entity, entity.name, writer)
        if (entity && entity.children !== null && entity.children !== undefined) {
          // Hiearchical
          entity.children.forEach((child: any) => {
            writeEntity(
              Utils.entity(child),
              child,
              writer
            )
          })
        }
      })
    }

    writeEntities(
      app.prebuiltEntities,
      app,
      'Built-in entities',
      writer
    )
    writeEntities(app.closedLists, app, 'Lists', writer)
    writeEntities(
      app.regex_entities,
      app,
      'Regex entities',
      writer
    )
    writeEntities(
      app.patternAnyEntities,
      app,
      'Pattern.any',
      writer
    )

    // Composites
    if (
      app.composites !== null &&
      app.composites !== undefined &&
      app.composites.length > 0
    ) {
      writer.writeLine()
      writer.writeLineIndented('// Composites')
      let first = true
      app.composites.forEach((composite: any) => {
        if (first) {
          first = false
        } else {
          writer.writeLine()
        }
        let name = Utils.normalizeName(composite.name)
        writer.writeLineIndented(`public class _Instance${name}`)
        writer.writeLineIndented('{')
        writer.increaseIndentation()
        composite.children.forEach((child: any) => {
          let childName = propertyName(child)
          writer.writeLineIndented(`public InstanceData[] ${childName};`)
        })
        writer.decreaseIndentation()
        writer.writeLineIndented('}')
        writer.writeLineIndented(`public class ${name}Class`)
        writer.writeLineIndented('{')
        writer.increaseIndentation()
        composite.children.forEach((child: any) => {
          writeEntity(
            Utils.entity(child),
            Utils.isList(child, app) ? 'list' : child,
            writer
          )
        })
        writer.writeLineIndented('[JsonProperty("$instance")]')
        writer.writeLineIndented(`public _Instance${name} _instance;`)
        writer.decreaseIndentation()
        writer.writeLineIndented('}')
        writer.writeLineIndented(`public ${name}Class[] ${name};`)
      })
    }

    // Instance
    writer.writeLine()
    writer.writeLineIndented('// Instance')
    writer.writeLineIndented('public class _Instance')
    writer.writeLineIndented('{')
    writer.increaseIndentation()
    Utils.writeInstances(app, name => {
      let realName = propertyName(name)
      writer.writeLineIndented(`public InstanceData[] ${realName};`)
    })
    writer.decreaseIndentation()
    writer.writeLineIndented('}')
    writer.writeLineIndented('[JsonProperty("$instance")]')
    writer.writeLineIndented('public _Instance _instance;')

    writer.decreaseIndentation()
    writer.writeLineIndented('}') // Entities
    writer.writeLineIndented('[JsonProperty("entities")]')
    writer.writeLineIndented('public _Entities Entities;')
  }

  export function converter(className: string, writer: Writer): void {
    writer.writeLine()
    writer.writeLineIndented('public void Convert(dynamic result)')
    writer.writeLineIndented('{')
    writer.increaseIndentation()
    writer.writeLineIndented(
      `var app = JsonConvert.DeserializeObject<${className}>(JsonConvert.SerializeObject(result, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }));`
    )
    writer.writeLineIndented('Text = app.Text;')
    writer.writeLineIndented('AlteredText = app.AlteredText;')
    writer.writeLineIndented('Intents = app.Intents;')
    writer.writeLineIndented('Entities = app.Entities;')
    writer.writeLineIndented('Properties = app.Properties;')
    writer.decreaseIndentation()
    writer.writeLineIndented('}')
  }

  export function topScoringIntent(writer: Writer): void {
    writer.writeLine()
    writer.writeLineIndented(
      'public (Intent intent, double score) TopIntent()'
    )
    writer.writeLineIndented('{')
    writer.increaseIndentation()
    writer.writeLineIndented('Intent maxIntent = Intent.None;')
    writer.writeLineIndented('var max = 0.0;')
    writer.writeLineIndented('foreach (var entry in Intents)')
    writer.writeLineIndented('{')
    writer.increaseIndentation()
    writer.writeLineIndented('if (entry.Value.Score > max)')
    writer.writeLineIndented('{')
    writer.increaseIndentation()
    writer.writeLineIndented('maxIntent = entry.Key;')
    writer.writeLineIndented('max = entry.Value.Score.Value;')
    writer.decreaseIndentation()
    writer.writeLineIndented('}')
    writer.decreaseIndentation()
    writer.writeLineIndented('}')
    writer.writeLineIndented('return (maxIntent, max);')
    writer.decreaseIndentation()
    writer.writeLineIndented('}')
  }

  export async function generate(
    description: string,
    app: any,
    className: string,
    space: string,
    outPath: string,
    command: Command
  ): Promise<void> {
    const outName = `${outPath}/${className}.cs`
    command.log(
      `Generating file ${outName} that contains class ${space}.${className}.`
    )
    let writer = new Writer()
    await writer.setOutputStream(outName)
    header(description, space, className, writer)
    writer.writeLine()
    intents(app.intents, writer)
    entities(app, writer)

    writer.writeLine()
    writer.writeLineIndented(
      '[JsonExtensionData(ReadData = true, WriteData = true)]'
    )
    writer.writeLineIndented(
      'public IDictionary<string, object> Properties {get; set; }'
    )

    converter(className, writer)
    topScoringIntent(writer)

    writer.decreaseIndentation()
    writer.writeLineIndented('}') // Class

    writer.decreaseIndentation()
    writer.writeLineIndented('}') // Namespace

    await writer.closeOutputStream()
  }
}
