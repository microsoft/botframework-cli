import {Command} from '@oclif/command'

import {Utils} from './utils'
import {Writer} from './writer'

export function header(
  description: string,
  space: string,
  className: string,
  writer: Writer
): void {
  writer.writeLine(
    `// <auto-generated>
// Code generated by ${description}
// Tool github: https://github.com/microsoft/botbuilder-tools
// Changes may cause incorrect behavior and will be lost if the code is
// regenerated.
// </auto-generated>
using Newtonsoft.Json;
using System.Collections.Generic;
using Microsoft.Bot.Builder;
using Microsoft.Bot.Builder.AI.Luis;
namespace ${space}
{{`
  )
  writer.increaseIndentation()

  //Main class
  writer.writeLineIndented(
    `public partial class ${className}: IRecognizerConvert`
  )
  writer.writeLineIndented('{')
  writer.increaseIndentation()

  //Text
  writer.writeLineIndented('[JsonProperty("text")]')
  writer.writeLineIndented('public string Text;')
  writer.increaseIndentation()
  writer.writeLineIndented('[JsonProperty("alteredText")]')
  writer.writeLineIndented('public string AlteredText;')
}

export function intents(intents: any, writer: Writer): void {
  writer.writeLineIndented('public enum Intent {')
  writer.increaseIndentation()
  let firstIntent = true
  intents.forEach((intent: any) => {
    if (firstIntent) {
      firstIntent = false
    } else {
      writer.writeLine(', ')
    }
    writer.writeIndented(Utils.normalizeName(intent.name))
  })
  writer.writeLine()
  writer.decreaseIndentation()

  writer.writeLineIndented('};') // Intent enum
  writer.writeLineIndented('[JsonProperty("intents")]')
  writer.writeLineIndented('public Dictionary<Intent, IntentScore> Intents;')
}

export function propertyName(name: any): string {
  return Utils.jsonPropertyName(name)
}

export function writeEntity(
  entity: any,
  type: any,
  writer: Writer
): void {
  Utils.entityApply(entity, ((name: string) => {
    const realName = propertyName(name)
    switch (type as string) {
    case 'age':
      writer.writeLineIndented(`public Age[] ${realName};`)
      break
    case 'datetimeV2':
      writer.writeLineIndented(`public DateTimeSpec[] ${realName};`)
      break
    case 'dimension':
      writer.writeLineIndented(`public Dimension[] ${realName};`)
      break
    case 'geographyV2':
      writer.writeLineIndented(`public GeographyV2[] ${realName};`)
      break
    case 'list':
      writer.writeLineIndented(`public string[][] ${realName};`)
      break
    case 'money':
      writer.writeLineIndented(`public Money[] ${realName};`)
      break
    case 'ordinalV2':
      writer.writeLineIndented(`public OrdinalV2[] ${realName};`)
      break
    case 'temperature':
      writer.writeLineIndented(`public Temperature[] ${realName};`)
      break
    case 'number':
    case 'ordinal':
    case 'percentage':
      writer.writeLineIndented(`public double[] ${realName};`)
      break
    default:
      writer.writeLineIndented(`public string[] ${realName};`)
    }
  }))
}

export function writeEntities(
  entities: Array<any>,
  app: any,
  description: string,
  writer: Writer
): void {
  if (entities.length > 0) {
    writer.writeLine()
    writer.writeLineIndented(`// ${description}`)
    let first = true
    entities.forEach(entity => {
      if (first) {
        first = false
      } else {
        writer.writeLine()
      }
      writeEntity(
        entity,
        Utils.isList(entity.name, app) ? 'list' : entity.name,
        writer
      )
    })
  }
}

export function entities(app: any, writer: Writer): void {
  // Entities
  writer.writeLine()
  writer.writeLineIndented('public class _Entities')
  writer.writeLineIndented('{')
  writer.increaseIndentation()
  if (
    app.entities !== null &&
    app.entities !== undefined &&
    app.entities.length > 0
  ) {
    writer.writeLineIndented('// Simple entities')
    let first = true
    app.entities.forEach((entity: any) => {
      if (first) {
        first = false
      } else {
        writer.writeLine()
      }
      writeEntity(entity, entity.name, writer)
      if (entity && entity.children !== null && entity.children !== undefined) {
        // Hiearchical
        entity.children.forEach((child: any) => {
          writeEntity(
            Utils.entity(child),
            child,
            writer
          )
        })
      }
    })
  }

  writeEntities(
    app.prebuiltEntities,
    app,
    'Built-in entities',
    writer
  )
  writeEntities(app.closedLists, app, 'Lists', writer)
  writeEntities(
    app.regex_entities,
    app,
    'Regex entities',
    writer
  )
  writeEntities(
    app.patternAnyEntities,
    app,
    'Pattern.any',
    writer
  )

  // Composites
  if (
    app.composites !== null &&
    app.composites !== undefined &&
    app.composites.length > 0
  ) {
    writer.writeLine()
    writer.writeLineIndented('// Composites')
    let first = true
    app.composites.forEach((composite: any) => {
      if (first) {
        first = false
      } else {
        writer.writeLine()
      }
      let name = Utils.normalizeName(composite.name)
      writer.writeLineIndented(`public class _Instance${name}`)
      writer.writeLineIndented('{')
      writer.increaseIndentation()
      composite.children.forEach((child: any) => {
        let childName = propertyName(child)
        writer.writeLineIndented(`public InstanceData[] ${childName};`)
      })
      writer.decreaseIndentation()
      writer.writeLineIndented('}')
      writer.writeLineIndented(`public class ${name}Class`)
      writer.writeLineIndented('{')
      writer.increaseIndentation()
      composite.children.forEach((child: any) => {
        writeEntity(
          Utils.entity(child),
          Utils.isList(child, app) ? 'list' : child,
          writer
        )
      })
      writer.writeLineIndented('[JsonProperty("$instance")]')
      writer.writeLineIndented(`public _Instance${name} _instance;`)
      writer.decreaseIndentation()
      writer.writeLineIndented('}')
      writer.writeLineIndented(`public {name}Class[] ${name};`)
    })
  }

  // Instance
  writer.writeLine()
  writer.writeLineIndented('// Instance')
  writer.writeLineIndented('public class _Instance')
  writer.writeLineIndented('{')
  writer.increaseIndentation()
  Utils.writeInstances(app, name => {
    let realName = propertyName(name)
    writer.writeLineIndented(`public InstanceData[] ${realName};`)
  })
  writer.decreaseIndentation()
  writer.writeLineIndented('}')
  writer.writeLineIndented('[JsonProperty("$instance")]')
  writer.writeLineIndented('public _Instance _instance;')

  writer.decreaseIndentation()
  writer.writeLineIndented('}') // Entities
  writer.writeLineIndented('[JsonProperty("entities")]')
  writer.writeLineIndented('public _Entities Entities;')
}

export function converter(className: string, writer: Writer): void {
  writer.writeLine()
  writer.writeLineIndented('public void Convert(dynamic result)')
  writer.writeLineIndented('{')
  writer.increaseIndentation()
  writer.writeLineIndented(
    `var app = JsonConvert.DeserializeObject<${className}>(JsonConvert.SerializeObject(result, new JsonSerializerSettings {{ NullValueHandling = NullValueHandling.Ignore }}));`
  )
  writer.writeLineIndented('Text = app.Text;')
  writer.writeLineIndented('AlteredText = app.AlteredText;')
  writer.writeLineIndented('Intents = app.Intents;')
  writer.writeLineIndented('Entities = app.Entities;')
  writer.writeLineIndented('Properties = app.Properties;')
  writer.decreaseIndentation()
  writer.writeLineIndented('}')
}

export function topScoringIntent(writer: Writer): void {
  writer.writeLine()
  writer.writeLineIndented(
    'public (Intent intent, double score) TopIntent()'
  )
  writer.writeLineIndented('{')
  writer.increaseIndentation()
  writer.writeLineIndented('Intent maxIntent = Intent.None;')
  writer.writeLineIndented('var max = 0.0;')
  writer.writeLineIndented('foreach (var entry in Intents)')
  writer.writeLineIndented('{')
  writer.increaseIndentation()
  writer.writeLineIndented('if (entry.Value.Score > max)')
  writer.writeLineIndented('{')
  writer.increaseIndentation()
  writer.writeLineIndented('maxIntent = entry.Key;')
  writer.writeLineIndented('max = entry.Value.Score.Value;')
  writer.decreaseIndentation()
  writer.writeLineIndented('}')
  writer.decreaseIndentation()
  writer.writeLineIndented('}')
  writer.writeLineIndented('return (maxIntent, max);')
  writer.decreaseIndentation()
  writer.writeLineIndented('}')
}

export async function generate(
  description: string,
  app: any,
  className: string,
  space: string,
  outPath: string,
  command: Command
): Promise<void> {
  const outName = `${outPath}/${className}.cs`
  command.log(
    `Generating file ${outName} that contains class ${space}.${className}.`
  )
  let writer = new Writer()
  await writer.setOutputStream(outName)
  header(description, space, className, writer)
  writer.writeLine()
  intents(app.intents, writer)
  entities(app, writer)

  writer.writeLine()
  writer.writeLineIndented(
    '[JsonExtensionData(ReadData = true, WriteData = true)]'
  )
  writer.writeLineIndented(
    'public IDictionary<string, object> Properties {get; set; }'
  )

  converter(className, writer)
  topScoringIntent(writer)

  writer.decreaseIndentation()
  writer.writeLineIndented('}') // Class

  writer.decreaseIndentation()
  writer.writeLineIndented('}') // Namespace

  await writer.closeOutputStream()
}
