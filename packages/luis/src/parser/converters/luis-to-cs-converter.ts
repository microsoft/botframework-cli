import {ParseMultiPlatformLuis} from '../luisfile/parse-multi-platform-luis'

import {Writer} from './helpers/writer'

import MultiPlatformLuis = ParseMultiPlatformLuis.MultiPlatformLuis

export namespace LuisToCsConverter {
  export async function writeFromLuisJson(
    luisJson: any,
    className: string,
    space: string,
    outPath: string
  ) {
    const app = ParseMultiPlatformLuis.fromLuisApp(luisJson)
    let writer = new Writer()
    await writer.setOutputStream(outPath)
    header(space, className, writer)
    writer.writeLine()
    intents(app.intents, writer)
    entities(app, writer)

    writer.writeLine()
    writer.writeLineIndented([
      '[JsonExtensionData(ReadData = true, WriteData = true)]',
      'public IDictionary<string, object> Properties {get; set; }'
    ])

    converter(className, writer)
    topScoringIntent(writer)

    writer.decreaseIndentation()
    writer.writeLineIndented('}') // Class

    writer.decreaseIndentation()
    writer.writeLineIndented('}') // Namespace

    await writer.closeOutputStream()
  }

  function header(
    space: string,
    className: string,
    writer: Writer
  ): void {
    writer.writeLine([
      '// <auto-generated>',
      '// Code generated by luis:generate:cs',
      '// Tool github: https://github.com/microsoft/botframwork-cli',
      '// Changes may cause incorrect behavior and will be lost if the code is',
      '// regenerated.',
      '// </auto-generated>',
      'using Newtonsoft.Json;',
      'using System.Collections.Generic;',
      'using Microsoft.Bot.Builder;',
      'using Microsoft.Bot.Builder.AI.Luis;',
      `namespace ${space}`,
      '{'
    ])
    writer.increaseIndentation()

    //Main class
    writer.writeLineIndented([
      `public partial class ${className}: IRecognizerConvert`,
      '{'
    ])
    writer.increaseIndentation()

    //Text
    writer.writeLineIndented([
      '[JsonProperty("text")]',
      'public string Text;'
    ])
    writer.writeLine()
    writer.writeLineIndented([
      '[JsonProperty("alteredText")]',
      'public string AlteredText;'
    ])
  }

  function intents(intents: string[], writer: Writer) {
    writer.writeLineIndented('public enum Intent {')
    writer.increaseIndentation()
    const lastIntent = intents.pop()

    intents.forEach((intent: string) => {
      writer.writeLineIndented(`${intent},`)
    })

    if (lastIntent) {
      writer.writeLineIndented(lastIntent)
    }
    writer.decreaseIndentation()

    writer.writeLineIndented([
      '};', // Intent enum,
      '[JsonProperty("intents")]',
      'public Dictionary<Intent, IntentScore> Intents;'
    ])
  }

  function entities(app: MultiPlatformLuis, writer: Writer) {
    writer.writeLine()
    writer.writeLineIndented([
      'public class _Entities',
      '{'
    ])
    writer.increaseIndentation()

    writeEntityBlock(
      app.simpleEntities,
      'Simple entities',
      (entity: string) => {
        writer.writeLineIndented(getEntityWithType(entity))
      },
      writer
    )

    writeEntityBlock(
      app.builtInEntities,
      'Built-in entities',
      (entities: string[]) => {
        const entityType = entities[0]
        entities.forEach(entity => {
          writer.writeLineIndented(getEntityWithType(entity, entityType))
        })
      },
      writer
    )

    writeEntityBlock(
      app.listEntities,
      'Lists',
      (entity: string) => {
        writer.writeLineIndented(getEntityWithType(entity, 'list'))
      },
      writer
    )

    writeEntityBlock(
      app.regexEntities,
      'Regex entities',
      (entity: string) => {
        writer.writeLineIndented(getEntityWithType(entity))
      },
      writer
    )

    writeEntityBlock(
      app.patternEntities,
      'Pattern.any',
      (entity: string) => {
        writer.writeLineIndented(getEntityWithType(entity))
      },
      writer
    )

    // Composites
    if (
      app.composites.length > 0
    ) {
      writer.writeLine()
      writer.writeLineIndented('// Composites')
      let first = true
      app.composites.forEach(composite => {
        if (first) {
          first = false
        } else {
          writer.writeLine()
        }

        writer.writeLineIndented([
          `public class _Instance${composite.compositeName}`,
          '{'
        ])
        writer.increaseIndentation()

        composite.attributes.forEach(attr => {
          writer.writeLineIndented([
            `public InstanceData[] ${ParseMultiPlatformLuis.jsonPropertyName(attr)};`
          ])
        })

        writer.decreaseIndentation()
        writer.writeLineIndented([
          '}',
          `public class ${composite.compositeName}Class`,
          '{'
        ])
        writer.increaseIndentation()

        composite.attributes.forEach(attr => {
          writer.writeLineIndented(getEntityWithType(
            attr,
            app.listEntities.includes(attr) ? 'list' : attr
          ))
        })

        writer.writeLineIndented([
          '[JsonProperty("$instance")]',
          `public _Instance${composite.compositeName} _instance;`
        ])

        writer.decreaseIndentation()
        writer.writeLineIndented([
          '}',
          `public ${composite.compositeName}Class[] ${composite.compositeName};`
        ])
      })
    }

    // Instance
    writer.writeLine()
    writer.writeLineIndented([
      '// Instance',
      'public class _Instance',
      '{'
    ])
    writer.increaseIndentation()

    app.getInstancesList().forEach(instanceData => {
      writer.writeLineIndented(`public InstanceData[] ${ParseMultiPlatformLuis.jsonPropertyName(instanceData)};`)
    })

    writer.decreaseIndentation()
    writer.writeLineIndented([
      '}',
      '[JsonProperty("$instance")]',
      'public _Instance _instance;'
    ])

    writer.decreaseIndentation()
    writer.writeLineIndented([
      '}', // Entities
      '[JsonProperty("entities")]',
      'public _Entities Entities;'
    ])
  }

  function getEntityWithType(entityName: string, entityType = ''): string {
    let result = ''
    switch (entityType) {
    case 'age':
      result = 'public Age[]'
      break
    case 'datetimeV2':
      result = 'public DateTimeSpec[]'
      break
    case 'dimension':
      result = 'public Dimension[]'
      break
    case 'geographyV2':
      result = 'public GeographyV2[]'
      break
    case 'list':
      result = 'public string[][]'
      break
    case 'money':
      result = 'public Money[]'
      break
    case 'ordinalV2':
      result = 'public OrdinalV2[]'
      break
    case 'temperature':
      result = 'public Temperature[]'
      break
    case 'number':
    case 'ordinal':
    case 'percentage':
      result = 'public double[]'
      break
    default:
      result = 'public string[]'
    }
    return result + ` ${ParseMultiPlatformLuis.jsonPropertyName(entityName)};`
  }

  export function converter(className: string, writer: Writer): void {
    writer.writeLine()
    writer.writeLineIndented([
      'public void Convert(dynamic result)',
      '{'
    ])

    writer.increaseIndentation()
    writer.writeLineIndented([
      `var app = JsonConvert.DeserializeObject<${className}>(JsonConvert.SerializeObject(result, new JsonSerializerSettings { NullValueHandling = NullValueHandling.Ignore }));`,
      'Text = app.Text;',
      'AlteredText = app.AlteredText;',
      'Intents = app.Intents;',
      'Entities = app.Entities;',
      'Properties = app.Properties;'
    ])

    writer.decreaseIndentation()
    writer.writeLineIndented('}')
  }

  export function topScoringIntent(writer: Writer): void {
    writer.writeLine()
    writer.writeLineIndented([
      'public (Intent intent, double score) TopIntent()',
      '{'
    ])

    writer.increaseIndentation()
    writer.writeLineIndented([
      'Intent maxIntent = Intent.None;',
      'var max = 0.0;',
      'foreach (var entry in Intents)',
      '{'
    ])

    writer.increaseIndentation()
    writer.writeLineIndented([
      'if (entry.Value.Score > max)',
      '{'
    ])

    writer.increaseIndentation()
    writer.writeLineIndented([
      'maxIntent = entry.Key;',
      'max = entry.Value.Score.Value;'
    ])

    writer.decreaseIndentation()
    writer.writeLineIndented('}')

    writer.decreaseIndentation()
    writer.writeLineIndented([
      '}',
      'return (maxIntent, max);'
    ])

    writer.decreaseIndentation()
    writer.writeLineIndented('}')
  }

  function writeEntityBlock(entities: any[], message: string, logic: (x: any) => void, writer: Writer) {
    if (
      entities.length > 0
    ) {
      if (message !== '') {
        writer.writeLineIndented(`// ${message}`)
      }
      entities.forEach(logic)
      writer.writeLine()
    }
  }
}
